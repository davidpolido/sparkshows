import { A, O, U } from 'ts-toolbelt';
import { MergeFlat } from 'Object/Merge';
import { BuiltInObject } from 'Misc/BuiltInObject';

declare type Datum = Record<Key, any>;
declare type Vector<T, K extends keyof T = keyof T> = T[K][];
declare type Key = string | number;
declare type KeyOrFn<T> = keyof T | ((item: T) => unknown);
declare type Comparator<T> = (a: T, b: T) => number;
declare type Primitive = number | string | boolean | Date;
declare type NonFunctionValue = boolean | string | number | null | undefined | Array<any> | {
    [key: string]: NonFunctionValue;
};
declare type GroupKey<K = any> = [string, K];
declare type Grouped<T> = Map<GroupKey<any>, T[] | Grouped<T>>;
interface TidyContext {
    /** when grouped, tidy functions can access the grouping keys here */
    groupKeys?: Key[];
}
/**
 * Takes in array of items, outputs array of items
 */
declare type TidyFn<InputT extends object, OutputT = InputT> = (items: InputT[], context?: TidyContext) => OutputT[];
/**
 * Takes in grouped items and outputs some modified version that
 * will no longer be accepted in tidy flows.
 */
declare type TidyGroupExportFn<InputT extends object, ExportedT> = (items: InputT[], context?: TidyContext) => ExportedT;
declare type Granularity = 'd' | 'days' | 'day' | 'w' | 'week' | 'weeks' | 'm' | 'month' | 'months' | 'y' | 'year' | 'years';

/**
 * Forms a tidy pipeline that can be called with (items)
 * @param items array of items to manipulate
 * @param fns Tidy functions
 */
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, T7 extends object, T8 extends object, T9 extends object, T10 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyFn<T5, T6>, f7: TidyFn<T6, T7>, f8: TidyFn<T7, T8>, f9: TidyFn<T8, T9>, f10: TidyFn<T9, T10>): T10[];
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, T7 extends object, T8 extends object, T9 extends object, T10 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyFn<T5, T6>, f7: TidyFn<T6, T7>, f8: TidyFn<T7, T8>, f9: TidyFn<T8, T9>, f10: TidyGroupExportFn<T9, T10>): T10;
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, T7 extends object, T8 extends object, T9 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyFn<T5, T6>, f7: TidyFn<T6, T7>, f8: TidyFn<T7, T8>, f9: TidyFn<T8, T9>): T9[];
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, T7 extends object, T8 extends object, T9 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyFn<T5, T6>, f7: TidyFn<T6, T7>, f8: TidyFn<T7, T8>, f9: TidyGroupExportFn<T8, T9>): T9;
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, T7 extends object, T8 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyFn<T5, T6>, f7: TidyFn<T6, T7>, f8: TidyFn<T7, T8>): T8[];
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, T7 extends object, T8 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyFn<T5, T6>, f7: TidyFn<T6, T7>, f8: TidyGroupExportFn<T7, T8>): T8;
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, T7 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyFn<T5, T6>, f7: TidyFn<T6, T7>): T7[];
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, T7 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyFn<T5, T6>, f7: TidyGroupExportFn<T6, T7>): T7;
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyFn<T5, T6>): T6[];
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>, f6: TidyGroupExportFn<T5, T6>): T6;
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyFn<T4, T5>): T5[];
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>, f5: TidyGroupExportFn<T4, T5>): T5;
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyFn<T3, T4>): T4[];
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>, f4: TidyGroupExportFn<T3, T4>): T4;
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyFn<T2, T3>): T3[];
declare function tidy<T extends object, T1 extends object, T2 extends object, T3 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>, f3: TidyGroupExportFn<T2, T3>): T3;
declare function tidy<T extends object, T1 extends object, T2 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyFn<T1, T2>): T2[];
declare function tidy<T extends object, T1 extends object, T2 extends object>(items: T[], f1: TidyFn<T, T1>, f2: TidyGroupExportFn<T1, T2>): T2;
declare function tidy<T extends object, T1 extends object>(items: T[], f1: TidyFn<T, T1>): T1[];
declare function tidy<T extends object, T1 extends object>(items: T[], f1: TidyGroupExportFn<T, T1>): T1;

/**
 * Filters items
 * @param filterFn Returns true to keep the item, false to filter out
 */
declare function filter<T extends object>(filterFn: (item: T, index: number, array: T[]) => boolean): TidyFn<T>;

/**
 * Conditionally runs a tidy sub-flow
 */
declare function when<T extends object>(predicate: ((items: T[]) => boolean) | boolean, fns: TidyFn<any, any>[]): TidyFn<T, any>;

/**
 * Maps items
 * @param mapFn Maps items from one form to another
 */
declare function map<T extends object, OutputT>(mapFn: (item: T, index: number, array: T[]) => OutputT): TidyFn<T, OutputT>;

declare type SingleOrArray<T> = T | T[];

/**
 * Removes items with duplicate values for the specified keys.
 * If no keys provided, uses strict equality.
 *
 * @param keys Keys to compute distinct across
 */
declare function distinct<T extends object>(keys?: SingleOrArray<KeyOrFn<T>> | null | undefined): TidyFn<T>;

/**
 * Sorts items
 * @param comparators Given a, b return -1 if a comes before b, 0 if equal, 1 if after
 */
declare function arrange<T extends object>(comparators: SingleOrArray<Key | Comparator<T>>): TidyFn<T>;
/**
 * Creates an ascending comparator based on a key
 * @param key property key of T
 */
declare function asc<T>(key: Key): Comparator<T>;
/**
 * Creates a descending comparator based on a key
 * @param key property key of T
 */
declare function desc<T>(key: Key): Comparator<T>;
/**
 * Creates a comparator that sorts values based on a key
 * and a supplied array of the desired order for the values.
 * Items not found in the array will be sorted last.
 * @param order array of desired sort order
 */
declare function fixedOrder<T>(key: KeyOrFn<T>, order: Array<T[keyof T]>, options?: {
    position?: 'start' | 'end';
}): (a: T, b: T) => number;

declare type SummarizeSpec<T> = Record<Key, (items: T[]) => any>;
interface SummarizeOptions<T = any> {
    rest?: (key: keyof T) => (items: T[]) => any;
}
declare type SummarizedT<T extends object, SumSpec extends SummarizeSpec<T>, Options extends SummarizeOptions<T> | undefined> = {
    [K in keyof SumSpec]: ReturnType<SumSpec[K]>;
} & // if there is a 'rest' option, add in the other values from T
(NonNullable<Options>['rest'] extends Function ? Exclude<T, keyof SumSpec> : void);
/**
 * summarizes items
 */
declare function summarize<T extends object, SummarizedSpec extends SummarizeSpec<T> = SummarizeSpec<T>, Options extends SummarizeOptions<T> = SummarizeOptions<T>>(summarizeSpec: SummarizedSpec, options?: Options): TidyFn<T, A.Compute<SummarizedT<T, SummarizedSpec, Options>>>;
declare type SummaryKeyFn<T, K = keyof T> = (key: K) => (items: T[]) => any;
declare type SummaryFnOutput<T extends object, F extends SummaryKeyFn<T>> = ReturnType<ReturnType<F>>;
declare function summarizeAll<T extends object, F extends SummaryKeyFn<T>>(summaryFn: F): TidyFn<T, A.Compute<Record<keyof T, SummaryFnOutput<T, F>>>>;
declare function summarizeIf<T extends object, F extends SummaryKeyFn<T>>(predicateFn: (vector: Vector<T>) => boolean, summaryFn: F): TidyFn<T, A.Compute<Record<keyof T, SummaryFnOutput<T, F>>>>;
declare function summarizeAt<T extends object, Keys extends (keyof T)[], F extends SummaryKeyFn<T, Keys[number]>>(keys: Keys, summaryFn: F): TidyFn<T, A.Compute<Record<Keys[number], SummaryFnOutput<T, F>>>>;

declare type MutateSpecValue<T, O = any> = ((item: T) => O) | NonFunctionValue;
declare type MutateSpec<T> = Record<Key, MutateSpecValue<T>>;
declare type ResolvedObj<Obj extends Record<Key, MutateSpecValue<any>>> = {
    [K in keyof Obj]: Obj[K] extends (...args: any) => any ? ReturnType<Obj[K]> extends any[] ? ReturnType<Obj[K]>[number] : ReturnType<Obj[K]> : Obj[K];
};
declare type Mutated<T, MSpec extends MutateSpec<T>> = T & ResolvedObj<MSpec>;
declare type Compute<T> = A.Compute<T>;
/**
 * Mutates items, one item at a time. For mutating across multiple items,
 * use mutateWithSummary.
 * @param mutateSpec
 */
declare function mutate<T extends object, MSpec extends MutateSpec<T>>(mutateSpec: MSpec): TidyFn<T, Compute<Mutated<T, MSpec>>>;

/**
 * Adds a summarized total row
 */
declare function total<T extends object, SummarizedSpec extends SummarizeSpec<T> = SummarizeSpec<T>, MutSpec extends MutateSpec<T> = MutateSpec<T>>(summarizeSpec: SummarizedSpec, mutateSpec: MutSpec): TidyFn<T>;
/**
 * Adds a summarized total row
 */
declare function totalAll<T extends object, F extends SummaryKeyFn<T>, MutSpec extends MutateSpec<T> = MutateSpec<T>>(summaryFn: F, mutateSpec: MutSpec): TidyFn<T>;
/**
 * Adds a summarized total row
 */
declare function totalIf<T extends object, F extends SummaryKeyFn<T>, MutSpec extends MutateSpec<T> = MutateSpec<T>>(predicateFn: (vector: Vector<T>) => boolean, summaryFn: F, mutateSpec: MutSpec): TidyFn<T>;
/**
 * Adds a summarized total row
 */
declare function totalAt<T extends object, Keys extends (keyof T)[], F extends SummaryKeyFn<T, Keys[number]>, MutSpec extends MutateSpec<T> = MutateSpec<T>>(keys: Keys, summaryFn: F, mutateSpec: MutSpec): TidyFn<T>;

declare type CountOptions = {
    name?: string;
    sort?: boolean;
    wt?: string;
};
/**
 * Tallies the number distinct values for the specified keys and adds
 * the count as a new key (default `n`). Optionally sorts by the count.
 */
declare function count<T extends object, Keys extends SingleOrArray<KeyOrFn<T>>>(groupKeys: Keys, options?: CountOptions | null | undefined): (items: T[]) => (Keys extends keyof T ? MergeFlat<Pick<T, Keys>, {
    n: number;
}, BuiltInObject, never> : Keys extends (keyof T)[] ? MergeFlat<Pick<T, Keys[number]>, {
    n: number;
}, BuiltInObject, never> : {
    n: number;
})[];

declare type TallyOptions = {
    readonly name?: string;
    readonly wt?: string;
};
declare type TallyOutput<Options extends TallyOptions> = Options['name'] extends string ? {
    [K in Options['name']]: number;
} : {
    n: number;
};
declare function tally<T extends object, Options extends TallyOptions>(options?: Options): TidyFn<T, TallyOutput<Options>>;

/** [key, values] where values could be more nested entries */
declare type EntriesOutput = [any, any][];
declare type EntriesObjectOutput = {
    key: Key;
    values: any;
}[];
/** nested objects: { [key]: values } */
declare type ObjectOutput = Record<Key, any>;
/** nested keys: e.g. [key, key, key, [key, key, [key]]] */
declare type KeysOutput = any[];
/** nested values: e.g. [[value1_1, value1_2], [value2_1, value2_2]] */
declare type ValuesOutput = any[];
declare type LevelSpec = {
    id?: string;
    createEmptySubgroup: () => any;
    addSubgroup: (parentGrouped: any, newSubgroup: any, key: any, level: number) => void;
    addLeaf: (parentGrouped: any, key: any, values: any[], level: number) => void;
};
/**
 * Options to affect export type
 */
interface GroupByOptions {
    /** whether to merge group keys back into the objects */
    readonly addGroupKeys?: boolean;
    /** export method */
    readonly export?: 'grouped' | 'entries' | 'entries-object' | 'object' | 'map' | 'keys' | 'values' | 'levels' | 'ungrouped';
    /** if all nested levels should be brought to a single top level */
    readonly flat?: boolean;
    /** when flat is true, how to flatten nested keys */
    readonly compositeKey?: (keys: any[]) => string;
    /** whether the leaf sets consist of just one item (typical after summarize).
     *  if true, uses the first element in the leaf set instead of an array
     */
    readonly single?: boolean;
    /** operation called on each leaf during export to map it to a different value
     *  (default: identity)
     */
    readonly mapLeaf?: (value: any) => any;
    /** operation called on each leaf set to map the array of values to a different value.
     * Similar to `rollup` from d3-collection nest or d3-array
     * (default: identity)
     */
    readonly mapLeaves?: (values: any[]) => any;
    /** [entries only] operation called on entries to map from [key, values] to
     * whatever the output of this is (e.g. `{ key, values }`)
     * (default: identity)
     */
    readonly mapEntry?: (entry: [any, any], level: number) => any;
    /** [required for levels] specifies the export operation for each level of the grouping */
    readonly levels?: ('entries' | 'entries-object' | 'object' | 'map' | 'keys' | 'values' | LevelSpec)[];
}
declare type GK<T extends object> = SingleOrArray<keyof T | ((d: T) => any)>;
declare type F<I extends object, O extends object> = TidyFn<I, O>;
declare type MergeGroupKeys<T extends object, Out extends object, Keys extends GK<T>> = Keys extends keyof T ? O.Merge<Pick<T, Keys>, Out> : Keys extends (keyof T)[] ? O.Merge<Pick<T, Keys[number]>, Out> : Out;
declare type WithGroupKeys<T extends object, Out extends object, Keys extends GK<T>, Opts extends GroupByOptions | undefined> = NonNullable<Opts>['addGroupKeys'] extends false ? Out : MergeGroupKeys<T, Out, Keys>;
/**
 * output varies based on export options
 */
declare type GroupByOutput<T extends object, O extends object, Keys extends GK<T>, Opts extends GroupByOptions | undefined> = A.Compute<NonNullable<Opts>['export'] extends 'grouped' ? Grouped<WithGroupKeys<T, O, Keys, Opts>> : NonNullable<Opts>['export'] extends 'entries' ? EntriesOutput : NonNullable<Opts>['export'] extends 'entries-object' ? EntriesObjectOutput : NonNullable<Opts>['export'] extends 'object' ? ObjectOutput : NonNullable<Opts>['export'] extends 'map' ? Map<any, any> : NonNullable<Opts>['export'] extends 'keys' ? KeysOutput : NonNullable<Opts>['export'] extends 'values' ? ValuesOutput : NonNullable<Opts>['export'] extends 'levels' ? any : WithGroupKeys<T, O, Keys, Opts>[]>;
declare type GroupByFn<T extends object, O extends object, Keys extends GK<T>, Opts extends GroupByOptions> = Opts['export'] extends 'grouped' | 'entries' | 'entries-object' | 'object' | 'map' | 'keys' | 'values' | 'levels' ? TidyGroupExportFn<T, GroupByOutput<T, O, Keys, Opts>> : TidyFn<T, WithGroupKeys<T, O, Keys, Opts>>;
/**
 * Nests the data by the specified groupings
 */
declare function groupBy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, T7 extends object, Keys extends GK<T>, Opts extends GroupByOptions>(groupKeys: Keys, fns: [F<T, T1>, F<T1, T2>, F<T2, T3>, F<T3, T4>, F<T4, T5>, F<T5, T6>, F<T6, T7>], options?: Opts): GroupByFn<T, T7, Keys, Opts>;
declare namespace groupBy {
    var grouped: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "grouped";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entries: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entriesObject: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries-object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var object: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var map: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "map";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var keys: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "keys";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var values: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "values";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var levels: (options?: Pick<GroupByOptions, "flat" | "levels" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "levels";
        readonly flat?: boolean | undefined;
        readonly levels?: ("object" | "map" | "entries" | "keys" | "values" | LevelSpec | "entries-object")[] | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
}
declare function groupBy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, T6 extends object, Keys extends GK<T>, Opts extends GroupByOptions>(groupKeys: Keys, fns: [F<T, T1>, F<T1, T2>, F<T2, T3>, F<T3, T4>, F<T4, T5>, F<T5, T6>], options?: Opts): GroupByFn<T, T6, Keys, Opts>;
declare namespace groupBy {
    var grouped: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "grouped";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entries: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entriesObject: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries-object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var object: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var map: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "map";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var keys: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "keys";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var values: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "values";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var levels: (options?: Pick<GroupByOptions, "flat" | "levels" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "levels";
        readonly flat?: boolean | undefined;
        readonly levels?: ("object" | "map" | "entries" | "keys" | "values" | LevelSpec | "entries-object")[] | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
}
declare function groupBy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, T5 extends object, Keys extends GK<T>, Opts extends GroupByOptions>(groupKeys: Keys, fns: [F<T, T1>, F<T1, T2>, F<T2, T3>, F<T3, T4>, F<T4, T5>], options?: Opts): GroupByFn<T, T5, Keys, Opts>;
declare namespace groupBy {
    var grouped: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "grouped";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entries: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entriesObject: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries-object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var object: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var map: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "map";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var keys: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "keys";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var values: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "values";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var levels: (options?: Pick<GroupByOptions, "flat" | "levels" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "levels";
        readonly flat?: boolean | undefined;
        readonly levels?: ("object" | "map" | "entries" | "keys" | "values" | LevelSpec | "entries-object")[] | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
}
declare function groupBy<T extends object, T1 extends object, T2 extends object, T3 extends object, T4 extends object, Keys extends GK<T>, Opts extends GroupByOptions>(groupKeys: Keys, fns: [F<T, T1>, F<T1, T2>, F<T2, T3>, F<T3, T4>], options?: Opts): GroupByFn<T, T4, Keys, Opts>;
declare namespace groupBy {
    var grouped: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "grouped";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entries: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entriesObject: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries-object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var object: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var map: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "map";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var keys: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "keys";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var values: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "values";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var levels: (options?: Pick<GroupByOptions, "flat" | "levels" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "levels";
        readonly flat?: boolean | undefined;
        readonly levels?: ("object" | "map" | "entries" | "keys" | "values" | LevelSpec | "entries-object")[] | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
}
declare function groupBy<T extends object, T1 extends object, T2 extends object, T3 extends object, Keys extends GK<T>, Opts extends GroupByOptions>(groupKeys: Keys, fns: [F<T, T1>, F<T1, T2>, F<T2, T3>], options?: Opts): GroupByFn<T, T3, Keys, Opts>;
declare namespace groupBy {
    var grouped: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "grouped";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entries: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entriesObject: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries-object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var object: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var map: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "map";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var keys: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "keys";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var values: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "values";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var levels: (options?: Pick<GroupByOptions, "flat" | "levels" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "levels";
        readonly flat?: boolean | undefined;
        readonly levels?: ("object" | "map" | "entries" | "keys" | "values" | LevelSpec | "entries-object")[] | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
}
declare function groupBy<T extends object, T1 extends object, T2 extends object, Keys extends GK<T>, Opts extends GroupByOptions>(groupKeys: Keys, fns: [F<T, T1>, F<T1, T2>], options?: Opts): GroupByFn<T, T2, Keys, Opts>;
declare namespace groupBy {
    var grouped: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "grouped";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entries: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entriesObject: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries-object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var object: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var map: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "map";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var keys: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "keys";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var values: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "values";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var levels: (options?: Pick<GroupByOptions, "flat" | "levels" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "levels";
        readonly flat?: boolean | undefined;
        readonly levels?: ("object" | "map" | "entries" | "keys" | "values" | LevelSpec | "entries-object")[] | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
}
declare function groupBy<T extends object, T1 extends object, Keys extends GK<T>, Opts extends GroupByOptions>(groupKeys: Keys, fns: [F<T, T1>], options?: Opts): GroupByFn<T, T1, Keys, Opts>;
declare namespace groupBy {
    var grouped: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "grouped";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entries: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entriesObject: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries-object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var object: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var map: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "map";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var keys: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "keys";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var values: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "values";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var levels: (options?: Pick<GroupByOptions, "flat" | "levels" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "levels";
        readonly flat?: boolean | undefined;
        readonly levels?: ("object" | "map" | "entries" | "keys" | "values" | LevelSpec | "entries-object")[] | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
}
declare function groupBy<T extends object, Keys extends GK<T>, Opts extends GroupByOptions>(groupKeys: Keys, fns: [], options?: Opts): GroupByFn<T, T, Keys, Opts>;
declare namespace groupBy {
    var grouped: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "grouped";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entries: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var entriesObject: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "entries-object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var object: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "object";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var map: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "map";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var keys: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "keys";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var values: (options?: Pick<GroupByOptions, "flat" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "values";
        readonly flat?: boolean | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
    var levels: (options?: Pick<GroupByOptions, "flat" | "levels" | "addGroupKeys" | "compositeKey" | "single" | "mapLeaf" | "mapLeaves" | "mapEntry"> | undefined) => {
        readonly export: "levels";
        readonly flat?: boolean | undefined;
        readonly levels?: ("object" | "map" | "entries" | "keys" | "values" | LevelSpec | "entries-object")[] | undefined;
        readonly addGroupKeys?: boolean | undefined;
        readonly compositeKey?: ((keys: any[]) => string) | undefined;
        readonly single?: boolean | undefined;
        readonly mapLeaf?: ((value: any) => any) | undefined;
        readonly mapLeaves?: ((values: any[]) => any) | undefined;
        readonly mapEntry?: ((entry: [any, any], level: number) => any) | undefined;
    };
}

declare type RenameSpec<T> = Partial<{
    [K in keyof T]: string;
}>;
declare type OutputT<T extends object, Spec extends RenameSpec<T>> = O.Merge<Omit<T, keyof Spec>, {
    [NewKey in Exclude<Spec[keyof Spec], undefined>]: T[O.SelectKeys<Spec, NewKey>];
}>;
/**
 * Renames properties/columns in collection
 *
 * @param renameSpec Mapping of current name to new name { currKey: newKey }
 */
declare function rename<T extends object, Spec extends RenameSpec<T>>(renameSpec: Spec): TidyFn<T, OutputT<T, Spec>>;

/**
 * Truncates the array to the specified range
 */
declare function slice<T extends object>(start: number, end?: number): TidyFn<T>;
/**
 * Truncates the array to the first N items
 */
declare const sliceHead: <T extends object>(n: number) => TidyFn<T, T>;
/**
 * Truncates the array to the last N items
 */
declare const sliceTail: <T extends object>(n: number) => TidyFn<T, T>;
/**
 * Truncates the array to the first N items ordered by some key
 */
declare function sliceMin<T extends object>(n: number, orderBy: SingleOrArray<Key | Comparator<T>>): TidyFn<T>;
/**
 * Truncates the array to the last N items ordered by some key
 */
declare function sliceMax<T extends object>(n: number, orderBy: SingleOrArray<Key | Comparator<T>>): TidyFn<T>;
declare type SampleOptions = {
    replace?: boolean;
};
/**
 * Truncates the array to the last N items ordered by some key
 */
declare function sliceSample<T extends object>(n: number, options?: SampleOptions | null | undefined): TidyFn<T>;

declare type ByMap<JoinT extends Datum, T extends Datum> = Partial<Record<keyof JoinT, keyof T>>;
declare type JoinOptions<JoinT extends Datum, T extends Datum> = {
    by?: keyof T | (keyof T)[] | ByMap<JoinT, T>;
};
/**
 * Performs an inner join on two collections
 * @param itemsToJoin The rows/items to be appended to end of collection
 */
declare function innerJoin<T extends object, JoinT extends object>(itemsToJoin: JoinT[], options?: JoinOptions<JoinT, T> | null | undefined): TidyFn<T, O.Merge<T, JoinT>>;

/**
 * Performs a left join on two collections
 * @param itemsToJoin The rows/items to be appended to end of collection
 */
declare function leftJoin<T extends Datum, JoinT extends Datum>(itemsToJoin: JoinT[], options?: JoinOptions<JoinT, T> | null | undefined): TidyFn<T, O.Merge<T, Partial<JoinT>>>;

declare type MutateSpecValue$1<T, O = any> = ((items: T[]) => O[] | O) | NonFunctionValue;
declare type MutateSummarySpec<T> = Record<Key, MutateSpecValue$1<T>>;
declare type ResolvedObj$1<Obj extends Record<Key, MutateSpecValue$1<any>>> = {
    [K in keyof Obj]: Obj[K] extends (...args: any) => any ? ReturnType<Obj[K]> extends any[] ? ReturnType<Obj[K]>[number] : ReturnType<Obj[K]> extends Float64Array ? number : ReturnType<Obj[K]> : Obj[K];
};
declare type Mutated$1<T, MSpec extends MutateSummarySpec<T>> = T & ResolvedObj$1<MSpec>;
declare type Compute$1<T> = A.Compute<T>;
/**
 * Mutates items, looking at multiple items at a time to enable summarization.
 * For simpler, item by item mutations, use mutate.
 * @param mutateSpec
 */
declare function mutateWithSummary<T extends object, MSpec extends MutateSummarySpec<T>>(mutateSpec: MSpec): TidyFn<T, Compute$1<Mutated$1<T, MSpec>>>;

/**
 * Transmutes items
 * @param mutateSpec
 */
declare function transmute<T extends object, MSpec extends MutateSpec<T>>(mutateSpec: MSpec): TidyFn<T, A.Compute<ResolvedObj<MSpec>>>;

declare type DropKey<T extends Datum> = keyof T extends string | number ? `-${keyof T}` : never;
declare type KeysInput<T> = (Key | ((items: T[]) => Key[]))[] | readonly DropKey<T>[] | readonly (keyof T)[] | DropKey<T> | keyof T;
declare type Output<T extends object, KS extends KeysInput<T>> = KS extends readonly DropKey<T>[] ? O.Pick<T, {
    [TK in keyof T]: `-${U.Intersect<TK, string>}` extends KS[number] ? never : TK;
}[keyof T]> : KS extends readonly Key[] ? O.Pick<T, KS[number]> : KS extends DropKey<T> ? O.Pick<T, {
    [TK in keyof T]: `-${U.Intersect<TK, string>}` extends KS ? never : TK;
}[keyof T]> : KS extends Key ? O.Pick<T, U.Intersect<KS, keyof T>> : T;
/**
 * selects subparts of the objects (aka pick)
 * @param selectFn Returns true to keep the item, false to select out
 */
declare function select<T extends object, Keys extends KeysInput<T>>(selectKeys: Keys): TidyFn<T, Output<T, Keys>>;

/**
 * adds items to the end of the collection
 * @param itemsToAdd The rows/items to be appended to end of collection
 */
declare function addRows<T extends object>(itemsToAdd: SingleOrArray<T> | ((items: T[]) => SingleOrArray<T>)): TidyFn<T>;

declare type PivotOutput = Record<Key, any>;
declare type PivotWiderOptions<T extends object> = {
    namesFrom: SingleOrArray<keyof T>;
    namesSep?: string;
    valuesFrom: SingleOrArray<keyof T>;
    valuesFill?: any;
    valuesFillMap?: Partial<Record<Key, any>>;
};
declare function pivotWider<T extends object>(options: PivotWiderOptions<T>): TidyFn<T, PivotOutput>;

declare type PivotLongerOptions = {
    cols?: any;
    namesTo: SingleOrArray<Key>;
    namesSep?: string;
    valuesTo: SingleOrArray<Key>;
};
declare type PivotOutput$1 = Record<Key, any>;
declare function pivotLonger<T extends object>(options: PivotLongerOptions): TidyFn<T, PivotOutput$1>;

declare type KeyMap<T extends object = any> = Partial<{
    [key in keyof T]: keyof T | Array<T[key]> | ((items: T[]) => T[key][]);
}>;
/**
 * Expands a set of items to include all combinations of the specified keys.
 */
declare function expand<T extends object = any, K extends keyof T = keyof T>(expandKeys: K): TidyFn<T, A.Compute<Pick<T, K>>>;
declare function expand<T extends object = any, K extends (keyof T)[] = (keyof T)[]>(expandKeys: K): TidyFn<T, A.Compute<Pick<T, K[number]>>>;
declare function expand<T extends object = any, K extends KeyMap<T> = KeyMap<T>>(expandKeys: K): TidyFn<T, O.Pick<T, keyof K>>;

/**
 * Create a full sequence given a vector of values
 */
declare function vectorSeq(values: number[], period?: number): number[];
/**
 * Create a full sequence given a vector of values
 */
declare function vectorSeqDate(values: Date[], granularity?: Granularity, period?: number): Date[];
/**
 * Create a full sequence given a set of data.
 * @param items
 * @param key
 */
declare function fullSeq<T extends object>(key: keyof T | ((d: T) => number), period?: number | null | undefined): (items: T[]) => number[];
declare function fullSeqDate<T extends object>(key: keyof T | ((d: T) => Date), granularity?: Granularity | null | undefined, period?: number | null | undefined): (items: T[]) => Date[];
declare function fullSeqDateISOString<T extends object>(key: keyof T | ((d: T) => string), granularity?: Granularity | null | undefined, period?: number | null | undefined): (items: T[]) => string[];

declare type Spec<T extends object> = {
    [K in keyof T]: T[K];
};
declare type Output$1<T extends object, ReplaceSpec extends Partial<Spec<T>>> = O.Merge<Omit<T, keyof ReplaceSpec>, {
    [K in keyof ReplaceSpec]: K extends keyof T ? Exclude<T[K], null | undefined> | ReplaceSpec[K] : ReplaceSpec[K];
}>;
/**
 * Replaces nully values with what is specified in the spec
 */
declare function replaceNully<T extends object, ReplaceSpec extends Spec<Partial<T>> = Spec<Partial<T>>>(replaceSpec: ReplaceSpec): TidyFn<T, Output$1<T, ReplaceSpec>>;

/**
 * Complete a collection with missing combinations of data
 * @param expandKeys The keys to expand to all combinations of
 * @param replaceNullySpec a map from key name to value of how to deal with undefined values
 */
declare function complete<T extends object>(expandKeys: SingleOrArray<Key> | KeyMap<T>, replaceNullySpec?: Partial<T> | null | undefined): TidyFn<T>;

/**
 * Fills values for the specified keys to match the last seen value in the collection.
 */
declare function fill<T extends object>(keys: SingleOrArray<Key>): TidyFn<T>;

declare type Options = {
    limit?: number | null;
    output?: 'log' | 'table';
};
/**
 * Debugs items
 */
declare function debug<T extends object>(label?: string | null | undefined, options?: Options | null | undefined): TidyFn<T>;

declare type RateOptions<T> = {
    predicate?: (d: T) => boolean;
    allowDivideByZero?: boolean;
};
/**
 * Returns a function that computes a rate (numerator / denominator), setting the value to
 * 0 if denominator = 0 and numerator = 0.
 */
declare function rate<T extends object>(numerator: keyof T | ((d: T) => number), denominator: keyof T | ((d: T) => number), options?: RateOptions<T>): (d: T) => number | undefined;

declare function cumsum<T extends object>(key: keyof T | ((d: T) => number | null | undefined)): (items: T[]) => Float64Array;

declare type RollOptions = {
    partial?: boolean;
};
/**
 * Returns a function that computes the a rolling value (e.g. moving average) by
 * applying a function over a window of data
 * @param width The size of the window
 * @param rollFn The function to apply to the window (should reduce to a single value)
 * @param options Options to configure roll. e.g. whether to run on partial windows.
 */
declare function roll<T extends object>(width: number, rollFn: (itemsInWindow: T[], endIndex: number) => any, options?: RollOptions | undefined | null): (items: any[]) => any[];

/**
 * Returns a function that computes the sum over an array of items
 * @param key A string key of the object or an accessor converting the object to a number
 */
declare function sum<T extends object>(key: keyof T | ((d: T) => number)): (items: T[]) => number;

/**
 * Returns a function that computes the min over an array of items
 * @param key A string key of the object or an accessor converting the object to a number
 */
declare function min<T extends object>(key: keyof T | ((d: T) => number)): (items: T[]) => number | undefined;

/**
 * Returns a function that computes the max over an array of items
 * @param key A string key of the object or an accessor converting the object to a number
 */
declare function max<T extends object>(key: keyof T | ((d: T) => number)): (items: T[]) => number | undefined;

/**
 * Returns a function that computes the mean over an array of items
 * @param key A string key of the object or an accessor converting the object to a number
 */
declare function mean<T extends object>(key: keyof T | ((d: T) => number)): (items: T[]) => number | undefined;

/**
 * Returns a function that computes the mean of a rate over an array of items
 * @param numerator A string key of the object or an accessor converting the object to a number
 * @param denominator A string key of the object or an accessor converting the object to a number
 */
declare function meanRate<T extends object>(numerator: keyof T | ((d: T) => number), denominator: keyof T | ((d: T) => number)): (items: T[]) => number | undefined;

/**
 * Returns a function that computes the median over an array of items
 * @param key A string key of the object or an accessor converting the object to a number
 */
declare function median<T extends object>(key: keyof T | ((d: T) => number)): (items: T[]) => number | undefined;

/**
 * Returns a function that computes the deviation over an array of items
 * @param key A string key of the object or an accessor converting the object to a number
 */
declare function deviation<T extends object>(key: keyof T | ((d: T) => number)): (items: T[]) => number | undefined;

/**
 * Returns a function that computes the variance over an array of items
 * @param key A string key of the object or an accessor converting the object to a number
 */
declare function variance<T extends object>(key: keyof T | ((d: T) => number)): (items: T[]) => number | undefined;

/**
 * Returns a function that computes the count over an array of items
 */
declare function n(): (items: any[]) => number;

/**
 * Returns a function that returns the first value for the specified key
 * @param key A string key of the object or an accessor converting the object to a number
 */
declare function first<T extends object>(key: keyof T | ((d: T) => number)): (items: T[]) => number | undefined;

/**
 * Returns a function that returns the last value for the specified key
 * @param key A string key of the object or an accessor converting the object to a number
 */
declare function last<T extends object>(key: keyof T | ((d: T) => number)): (items: T[]) => number | undefined;

/**
 * Returns all keys
 */
declare function everything<T extends object>(): (items: T[]) => (keyof T)[];

/**
 * Returns all keys that start with the specified prefix
 */
declare function startsWith<T extends object>(prefix: string, ignoreCase?: boolean): (items: T[]) => (keyof T)[];

/**
 * Returns all keys that end with the specified suffix
 */
declare function endsWith<T extends object>(suffix: string, ignoreCase?: boolean): (items: T[]) => (keyof T)[];

/**
 * Returns all keys that contain the specified substring
 */
declare function contains<T extends object>(substring: string, ignoreCase?: boolean): (items: T[]) => (keyof T)[];

/**
 * Returns all keys that match the specified regex
 */
declare function matches<T extends object>(regex: RegExp): (items: T[]) => (keyof T)[];

/**
 * Returns all keys that match the prefix + num range.
 * e.g., wk, [10, 15], width=3 -> wk010, wk011, wk012, wk013, wk014, wk015
 */
declare function numRange<T extends object>(prefix: string, range: [number, number], width?: number): (items: T[]) => (keyof T)[];

/**
 * Given a set of selectors, inverts their output to be drop keys. e.g.,
 * `key` becomes `-key`.
 */
declare function negate<T extends object>(selectors: SingleOrArray<keyof T | ((items: T[]) => (keyof T)[])>): (items: T[]) => (keyof T)[];

/** Tidy math helpers */
/** Compute a fraction while handling common edge cases */
declare function rate$1(numerator: number | null | undefined, denominator: number | null | undefined, allowDivideByZero?: boolean): number | undefined;

declare namespace math {
  export {
    rate$1 as rate,
  };
}

export { Comparator, Datum, Granularity, GroupKey, Grouped, Key, KeyOrFn, LevelSpec, NonFunctionValue, Primitive, SummarizeOptions, SummarizeSpec, math as TMath, TidyContext, TidyFn, TidyGroupExportFn, Vector, addRows as addItems, addRows, arrange, asc, complete, contains, count, cumsum, debug, desc, deviation, distinct, endsWith, everything, expand, fill, filter, first, fixedOrder, fullSeq, fullSeqDate, fullSeqDateISOString, groupBy, innerJoin, last, leftJoin, map, matches, max, mean, meanRate, median, min, mutate, mutateWithSummary, n, negate, numRange, select as pick, pivotLonger, pivotWider, rate, rename, replaceNully, roll, select, slice, sliceHead, sliceMax, sliceMin, sliceSample, sliceTail, arrange as sort, startsWith, sum, summarize, summarizeAll, summarizeAt, summarizeIf, tally, tidy, total, totalAll, totalAt, totalIf, transmute, variance, vectorSeq, vectorSeqDate, when };
