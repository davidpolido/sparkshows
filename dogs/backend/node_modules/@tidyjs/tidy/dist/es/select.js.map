{"version":3,"file":"select.js","sources":["../../src/select.ts"],"sourcesContent":["import { Datum, TidyFn, Key } from './types';\nimport { singleOrArray } from './helpers/singleOrArray';\nimport { everything } from './selectors/everything';\nimport { O, U } from 'ts-toolbelt';\n\ntype DropKey<T extends Datum> = keyof T extends string | number\n  ? `-${keyof T}`\n  : never;\n// type KeysInput1<T> = readonly (keyof T)[] | keyof T;\nexport type KeysInput<T> =\n  | (Key | ((items: T[]) => Key[]))[]\n  | readonly DropKey<T>[]\n  | readonly (keyof T)[]\n  | DropKey<T>\n  | keyof T;\n\ntype Output<\n  T extends object,\n  KS extends KeysInput<T>\n  // is it an array of drop keys?\n> = KS extends readonly DropKey<T>[]\n  ? O.Pick<\n      T,\n      {\n        [TK in keyof T]: `-${U.Intersect<TK, string>}` extends KS[number]\n          ? never\n          : TK;\n      }[keyof T]\n    >\n  : // is an array of keys?\n  KS extends readonly Key[]\n  ? O.Pick<T, KS[number]>\n  : // is a single drop key?\n  KS extends DropKey<T>\n  ? O.Pick<\n      T,\n      {\n        [TK in keyof T]: `-${U.Intersect<TK, string>}` extends KS ? never : TK;\n      }[keyof T]\n    >\n  : // is a single key?\n  KS extends Key\n  ? O.Pick<T, U.Intersect<KS, keyof T>>\n  : // any other case, just be dumb and say T was returned\n    T;\n\nexport function processSelectors<T extends object, Keys extends KeysInput<T>>(\n  items: T[],\n  selectKeys: Keys\n): string[] {\n  let processedSelectKeys: string[] = [];\n  // expand them all to a flat list of keys\n  for (const keyInput of singleOrArray(selectKeys as any)) {\n    if (typeof keyInput === 'function') {\n      processedSelectKeys.push(...(keyInput(items) as string[]));\n    } else {\n      processedSelectKeys.push(keyInput);\n    }\n  }\n\n  // if the first key is negative, add in everything at the front\n  if (processedSelectKeys.length && processedSelectKeys[0][0] === '-') {\n    processedSelectKeys = [...everything()(items), ...processedSelectKeys];\n  }\n\n  const negationMap: any = {};\n  const keysWithoutNegations = [];\n  // go through the list backwards and remove negations\n  for (let k = processedSelectKeys.length - 1; k >= 0; k--) {\n    const key: any = processedSelectKeys[k];\n    if (key[0] === '-') {\n      negationMap[key.substring(1)] = true;\n      continue;\n    }\n    if (negationMap[key]) {\n      negationMap[key] = false;\n      continue;\n    }\n    keysWithoutNegations.unshift(key);\n  }\n\n  // remove duplicates\n  processedSelectKeys = Array.from(new Set(keysWithoutNegations));\n\n  return processedSelectKeys;\n}\n\n/**\n * selects subparts of the objects (aka pick)\n * @param selectFn Returns true to keep the item, false to select out\n */\n// export function select<T extends object, Keys extends SingleOrArray<Key | ((items: T[]) => (keyof T)[])>>(\nexport function select<T extends object, Keys extends KeysInput<T>>(\n  selectKeys: Keys\n): TidyFn<T, Output<T, Keys>> {\n  type OutputT = Output<T, Keys>;\n  const _select: TidyFn<T, OutputT> = (items: T[]): OutputT[] => {\n    let processedSelectKeys: string[] = processSelectors(items, selectKeys);\n\n    if (!processedSelectKeys.length) return items as OutputT[];\n\n    // use the processed keys to create reduced objects\n    return items.map((d: T) => {\n      const mapped: any = {};\n      for (const key of processedSelectKeys) {\n        mapped[key] = d[key as keyof T];\n      }\n\n      return mapped;\n    });\n  };\n\n  return _select;\n}\n"],"names":[],"mappings":";;;0BA+CE,OACA;AAEA,MAAI,sBAAgC;AAEpC,aAAW,YAAY,cAAc;AACnC,QAAI,OAAO,aAAa;AACtB,0BAAoB,KAAK,GAAI,SAAS;AAAA;AAEtC,0BAAoB,KAAK;AAAA;AAAA;AAK7B,MAAI,oBAAoB,UAAU,oBAAoB,GAAG,OAAO;AAC9D,0BAAsB,CAAC,GAAG,aAAa,QAAQ,GAAG;AAAA;AAGpD,QAAM,cAAmB;AACzB,QAAM,uBAAuB;AAE7B,WAAS,IAAI,oBAAoB,SAAS,GAAG,KAAK,GAAG;AACnD,UAAM,MAAW,oBAAoB;AACrC,QAAI,IAAI,OAAO;AACb,kBAAY,IAAI,UAAU,MAAM;AAChC;AAAA;AAEF,QAAI,YAAY;AACd,kBAAY,OAAO;AACnB;AAAA;AAEF,yBAAqB,QAAQ;AAAA;AAI/B,wBAAsB,MAAM,KAAK,IAAI,IAAI;AAEzC,SAAO;AAAA;gBASP;AAGA,QAAM,UAA8B,CAAC;AACnC,QAAI,sBAAgC,iBAAiB,OAAO;AAE5D,QAAI,CAAC,oBAAoB;AAAQ,aAAO;AAGxC,WAAO,MAAM,IAAI,CAAC;AAChB,YAAM,SAAc;AACpB,iBAAW,OAAO;AAChB,eAAO,OAAO,EAAE;AAAA;AAGlB,aAAO;AAAA;AAAA;AAIX,SAAO;AAAA;;;;"}