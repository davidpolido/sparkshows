{"version":3,"file":"arrange.js","sources":["../../src/arrange.ts"],"sourcesContent":["import { ascending, descending } from 'd3-array';\nimport { SingleOrArray, singleOrArray } from './helpers/singleOrArray';\nimport { Comparator, Key, KeyOrFn, Primitive, TidyFn } from './types';\n\n/**\n * Sorts items\n * @param comparators Given a, b return -1 if a comes before b, 0 if equal, 1 if after\n */\nexport function arrange<T extends object>(\n  comparators: SingleOrArray<Key | Comparator<T>>\n): TidyFn<T> {\n  const _arrange: TidyFn<T> = (items: T[]): T[] => {\n    // expand strings `key` to `asc(key)`\n    const comparatorFns = singleOrArray(comparators).map((comp) =>\n      typeof comp === 'function' ? comp : asc<T>(comp)\n    );\n\n    return items.slice().sort((a, b) => {\n      for (const comparator of comparatorFns) {\n        const result = comparator(a, b);\n        if (result !== 0) return result;\n      }\n\n      return 0;\n    });\n  };\n\n  return _arrange;\n}\n\n/**\n * Creates an ascending comparator based on a key\n * @param key property key of T\n */\nexport function asc<T>(key: Key): Comparator<T> {\n  return function _asc(a: T, b: T) {\n    return ascending(\n      (a[key as keyof T] as unknown) as Primitive,\n      (b[key as keyof T] as unknown) as Primitive\n    );\n  };\n}\n\n/**\n * Creates a descending comparator based on a key\n * @param key property key of T\n */\nexport function desc<T>(key: Key): Comparator<T> {\n  return function _desc(a: T, b: T) {\n    return descending(\n      (a[key as keyof T] as unknown) as Primitive,\n      (b[key as keyof T] as unknown) as Primitive\n    );\n  };\n}\n\n/**\n * Creates a comparator that sorts values based on a key\n * and a supplied array of the desired order for the values.\n * Items not found in the array will be sorted last.\n * @param order array of desired sort order\n */\nexport function fixedOrder<T>(\n  key: KeyOrFn<T>,\n  order: Array<T[keyof T]>,\n  options?: { position?: 'start' | 'end' }\n): (a: T, b: T) => number {\n  let { position = 'start' } = options ?? {};\n  const positionFactor = position === 'end' ? -1 : 1;\n\n  const indexMap = new Map();\n  for (let i = 0; i < order.length; ++i) {\n    indexMap.set(order[i], i);\n  }\n\n  const keyFn =\n    typeof key === 'function'\n      ? key\n      : (d: T) => (d[key as keyof T] as unknown) as any;\n\n  return function _fixedOrder(a: T, b: T) {\n    const aIndex: number = indexMap.get(keyFn(a)) ?? -1;\n    const bIndex: number = indexMap.get(keyFn(b)) ?? -1;\n\n    if (aIndex >= 0 && bIndex >= 0) {\n      return aIndex - bIndex;\n    }\n\n    if (aIndex >= 0) {\n      return positionFactor * -1;\n    }\n\n    if (bIndex >= 0) {\n      return positionFactor * 1;\n    }\n\n    return 0;\n  };\n}\n"],"names":[],"mappings":";;;iBASE;AAEA,QAAM,WAAsB,CAAC;AAE3B,UAAM,gBAAgB,cAAc,aAAa,IAAI,CAAC,SACpD,OAAO,SAAS,aAAa,OAAO,IAAO;AAG7C,WAAO,MAAM,QAAQ,KAAK,CAAC,GAAG;AAC5B,iBAAW,cAAc;AACvB,cAAM,SAAS,WAAW,GAAG;AAC7B,YAAI,WAAW;AAAG,iBAAO;AAAA;AAG3B,aAAO;AAAA;AAAA;AAIX,SAAO;AAAA;aAOc;AACrB,SAAO,cAAc,GAAM;AACzB,WAAO,UACJ,EAAE,MACF,EAAE;AAAA;AAAA;cASe;AACtB,SAAO,eAAe,GAAM;AAC1B,WAAO,WACJ,EAAE,MACF,EAAE;AAAA;AAAA;oBAYP,KACA,OACA;AAEA,MAAI,CAAE,WAAW,WAAY,4BAAW;AACxC,QAAM,iBAAiB,aAAa,QAAQ,KAAK;AAEjD,QAAM,WAAW,IAAI;AACrB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE;AAClC,aAAS,IAAI,MAAM,IAAI;AAAA;AAGzB,QAAM,QACJ,OAAO,QAAQ,aACX,MACA,CAAC,MAAU,EAAE;AAEnB,SAAO,qBAAqB,GAAM;AAhFpC;AAiFI,UAAM,SAAiB,eAAS,IAAI,MAAM,QAAnB,YAA0B;AACjD,UAAM,SAAiB,eAAS,IAAI,MAAM,QAAnB,YAA0B;AAEjD,QAAI,UAAU,KAAK,UAAU;AAC3B,aAAO,SAAS;AAAA;AAGlB,QAAI,UAAU;AACZ,aAAO,iBAAiB;AAAA;AAG1B,QAAI,UAAU;AACZ,aAAO,iBAAiB;AAAA;AAG1B,WAAO;AAAA;AAAA;;;;"}