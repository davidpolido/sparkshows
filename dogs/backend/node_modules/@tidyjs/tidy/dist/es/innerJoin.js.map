{"version":3,"file":"innerJoin.js","sources":["../../src/innerJoin.ts"],"sourcesContent":["import { O } from 'ts-toolbelt';\nimport { TidyFn, Datum } from './types';\n\ntype ByMap<JoinT extends Datum, T extends Datum> = Partial<\n  Record<keyof JoinT, keyof T>\n>;\n\nexport type JoinOptions<JoinT extends Datum, T extends Datum> = {\n  by?: keyof T | (keyof T)[] | ByMap<JoinT, T>;\n};\n\n/**\n * Compares first two sets of items to find overlapping keys\n * Naively looks at first element... could cause problems if first\n * elements don't have all keys, but scanning each entire set seems\n * unnecessarily slow for most cases.\n */\nexport function autodetectByMap<A, B>(itemsA: A[], itemsB: B[]) {\n  if (itemsA.length === 0 || itemsB.length === 0) return {};\n\n  // intersection of shared keys\n  const keysA = Object.keys(itemsA[0]);\n  const keysB = Object.keys(itemsB[0]);\n\n  // naive linear intersection, but we don't expect objects to have tons of keys\n  // so it's probably fine.\n  const byMap: any = {};\n  for (const key of keysA) {\n    if (keysB.includes(key)) {\n      byMap[key] = key;\n    }\n  }\n\n  return byMap;\n}\n\n// convert by option in to a map from JoinT to T key\nexport function makeByMap<T extends Datum, JoinT extends Datum>(\n  by: JoinOptions<JoinT, T>['by']\n): ByMap<JoinT, T> {\n  // convert by option in to a map from JoinT to T key\n  if (Array.isArray(by)) {\n    const byMap: ByMap<JoinT, T> = {};\n    for (const key of by) {\n      byMap[key as any] = key;\n    }\n    return byMap;\n  } else if (typeof by === 'object') {\n    return by;\n  }\n  return { [by as keyof JoinT]: by as keyof T } as ByMap<JoinT, T>;\n}\n\nexport function isMatch<T extends object, JoinT extends object>(\n  d: T,\n  j: JoinT,\n  byMap: ByMap<JoinT, T>\n) {\n  for (const jKey in byMap) {\n    const dKey = byMap[jKey];\n    if ((d[dKey as keyof T] as any) !== j[jKey as keyof JoinT]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Performs an inner join on two collections\n * @param itemsToJoin The rows/items to be appended to end of collection\n */\nexport function innerJoin<T extends object, JoinT extends object>(\n  itemsToJoin: JoinT[],\n  options?: JoinOptions<JoinT, T> | null | undefined\n): TidyFn<T, O.Merge<T, JoinT>> {\n  const _innerJoin: TidyFn<T, O.Merge<T, JoinT>> = (\n    items: T[]\n  ): O.Merge<T, JoinT>[] => {\n    // convert by option in to a map from JoinT to T key\n    const byMap =\n      options?.by == null\n        ? autodetectByMap(items, itemsToJoin)\n        : makeByMap(options.by);\n\n    const joined = items.flatMap((d: T) => {\n      const matches = itemsToJoin.filter((j: JoinT) => isMatch(d, j, byMap));\n      return matches.map((j: JoinT) => ({ ...d, ...j }));\n    });\n\n    return joined as O.Merge<T, JoinT>[];\n  };\n  return _innerJoin;\n}\n"],"names":[],"mappings":"yBAiBsC,QAAa;AACjD,MAAI,OAAO,WAAW,KAAK,OAAO,WAAW;AAAG,WAAO;AAGvD,QAAM,QAAQ,OAAO,KAAK,OAAO;AACjC,QAAM,QAAQ,OAAO,KAAK,OAAO;AAIjC,QAAM,QAAa;AACnB,aAAW,OAAO;AAChB,QAAI,MAAM,SAAS;AACjB,YAAM,OAAO;AAAA;AAAA;AAIjB,SAAO;AAAA;mBAKP;AAGA,MAAI,MAAM,QAAQ;AAChB,UAAM,QAAyB;AAC/B,eAAW,OAAO;AAChB,YAAM,OAAc;AAAA;AAEtB,WAAO;AAAA,aACE,OAAO,OAAO;AACvB,WAAO;AAAA;AAET,SAAO,EAAG,KAAoB;AAAA;iBAI9B,GACA,GACA;AAEA,aAAW,QAAQ;AACjB,UAAM,OAAO,MAAM;AACnB,QAAK,EAAE,UAA6B,EAAE;AACpC,aAAO;AAAA;AAAA;AAGX,SAAO;AAAA;mBAQP,aACA;AAEA,QAAM,aAA2C,CAC/C;AAGA,UAAM,QACJ,oCAAS,OAAM,OACX,gBAAgB,OAAO,eACvB,UAAU,QAAQ;AAExB,UAAM,SAAS,MAAM,QAAQ,CAAC;AAC5B,YAAM,UAAU,YAAY,OAAO,CAAC,MAAa,QAAQ,GAAG,GAAG;AAC/D,aAAO,QAAQ,IAAI,CAAC,WAAmB,MAAM;AAAA;AAG/C,WAAO;AAAA;AAET,SAAO;AAAA;;;;"}