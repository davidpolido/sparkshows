{"version":3,"file":"mutateWithSummary.js","sources":["../../src/mutateWithSummary.ts"],"sourcesContent":["import { TidyFn, NonFunctionValue, Key } from './types';\nimport { A } from 'ts-toolbelt';\n\ntype MutateSpecValue<T, O = any> = ((items: T[]) => O[] | O) | NonFunctionValue;\nexport type MutateSummarySpec<T> = Record<Key, MutateSpecValue<T>>;\nexport type ResolvedObj<Obj extends Record<Key, MutateSpecValue<any>>> = {\n  [K in keyof Obj]: Obj[K] extends (...args: any) => any\n    ? ReturnType<Obj[K]> extends any[]\n      ? ReturnType<Obj[K]>[number]\n      : ReturnType<Obj[K]> extends Float64Array\n      ? number\n      : ReturnType<Obj[K]>\n    : Obj[K];\n};\n\ntype Mutated<T, MSpec extends MutateSummarySpec<T>> = T & ResolvedObj<MSpec>;\n\ntype Compute<T> = A.Compute<T>;\n\n/**\n * Mutates items, looking at multiple items at a time to enable summarization.\n * For simpler, item by item mutations, use mutate.\n * @param mutateSpec\n */\nexport function mutateWithSummary<\n  T extends object,\n  MSpec extends MutateSummarySpec<T>\n>(mutateSpec: MSpec): TidyFn<T, Compute<Mutated<T, MSpec>>> {\n  type MutatedT = Mutated<T, MSpec>;\n  // use Compute for better intellisense (reveals all keys in obj)\n  const _mutate: TidyFn<T, Compute<MutatedT>> = (\n    items: T[]\n  ): Compute<MutatedT>[] => {\n    // create the base items to merge mutated values into\n    const mutatedItems: MutatedT[] = items.map((d) => ({ ...d })) as MutatedT[];\n\n    // create vectors for each mutated value\n    for (const key in mutateSpec) {\n      // convert individual values to a vector of the same value\n      // this allows mutate functions to return single numbers and still work\n      const mutateSpecValue = mutateSpec[key];\n      const mutatedResult =\n        typeof mutateSpecValue === 'function'\n          ? mutateSpecValue(mutatedItems)\n          : mutateSpecValue;\n      const mutatedVector =\n        mutatedResult?.[Symbol.iterator] && typeof mutatedResult !== 'string'\n          ? mutatedResult\n          : items.map(() => mutatedResult);\n\n      // merge the mutated vector into the mutated items\n      let i = -1;\n      for (const mutatedItem of mutatedItems) {\n        mutatedItem[key as keyof MutatedT] = mutatedVector[++i];\n      }\n    }\n\n    return mutatedItems as Compute<MutatedT>[];\n  };\n\n  return _mutate;\n}\n"],"names":[],"mappings":";;;;2BA2BE;AAGA,QAAM,UAAwC,CAC5C;AAGA,UAAM,eAA2B,MAAM,IAAI,CAAC,WAAY;AAGxD,eAAW,OAAO;AAGhB,YAAM,kBAAkB,WAAW;AACnC,YAAM,gBACJ,OAAO,oBAAoB,aACvB,gBAAgB,gBAChB;AACN,YAAM,gBACJ,gDAAgB,OAAO,cAAa,OAAO,kBAAkB,WACzD,gBACA,MAAM,IAAI,MAAM;AAGtB,UAAI,IAAI;AACR,iBAAW,eAAe;AACxB,oBAAY,OAAyB,cAAc,EAAE;AAAA;AAAA;AAIzD,WAAO;AAAA;AAGT,SAAO;AAAA;;;;"}