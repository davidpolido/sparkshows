'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var d3Array = require('d3-array');
var singleOrArray = require('./helpers/singleOrArray.js');

function arrange(comparators) {
  const _arrange = (items) => {
    const comparatorFns = singleOrArray.singleOrArray(comparators).map((comp) => typeof comp === "function" ? comp : asc(comp));
    return items.slice().sort((a, b) => {
      for (const comparator of comparatorFns) {
        const result = comparator(a, b);
        if (result !== 0)
          return result;
      }
      return 0;
    });
  };
  return _arrange;
}
function asc(key) {
  return function _asc(a, b) {
    return d3Array.ascending(a[key], b[key]);
  };
}
function desc(key) {
  return function _desc(a, b) {
    return d3Array.descending(a[key], b[key]);
  };
}
function fixedOrder(key, order, options) {
  let {position = "start"} = options != null ? options : {};
  const positionFactor = position === "end" ? -1 : 1;
  const indexMap = new Map();
  for (let i = 0; i < order.length; ++i) {
    indexMap.set(order[i], i);
  }
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return function _fixedOrder(a, b) {
    var _a, _b;
    const aIndex = (_a = indexMap.get(keyFn(a))) != null ? _a : -1;
    const bIndex = (_b = indexMap.get(keyFn(b))) != null ? _b : -1;
    if (aIndex >= 0 && bIndex >= 0) {
      return aIndex - bIndex;
    }
    if (aIndex >= 0) {
      return positionFactor * -1;
    }
    if (bIndex >= 0) {
      return positionFactor * 1;
    }
    return 0;
  };
}

exports.arrange = arrange;
exports.asc = asc;
exports.desc = desc;
exports.fixedOrder = fixedOrder;
//# sourceMappingURL=arrange.js.map
