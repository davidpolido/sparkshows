{"version":3,"file":"summarize.js","sources":["../../src/summarize.ts"],"sourcesContent":["import { A } from 'ts-toolbelt';\nimport { singleOrArray } from './helpers/singleOrArray';\nimport { Key, TidyFn, Vector } from './types';\n\nexport type SummarizeSpec<T> = Record<Key, (items: T[]) => any>;\n\nexport interface SummarizeOptions<T = any> {\n  rest?: (key: keyof T) => (items: T[]) => any;\n}\n\ntype SummarizedT<\n  T extends object,\n  SumSpec extends SummarizeSpec<T>,\n  Options extends SummarizeOptions<T> | undefined\n> = {\n  // summarized values map to return type of the spec functions\n  [K in keyof SumSpec]: ReturnType<SumSpec[K]>;\n} & // if there is a 'rest' option, add in the other values from T\n  (NonNullable<Options>['rest'] extends Function\n    ? Exclude<T, keyof SumSpec>\n    : void);\n\n/**\n * summarizes items\n */\nexport function summarize<\n  T extends object,\n  SummarizedSpec extends SummarizeSpec<T> = SummarizeSpec<T>,\n  Options extends SummarizeOptions<T> = SummarizeOptions<T>\n>(\n  summarizeSpec: SummarizedSpec,\n  options?: Options\n): TidyFn<T, A.Compute<SummarizedT<T, SummarizedSpec, Options>>> {\n  type Output = SummarizedT<T, SummarizedSpec, Options>;\n\n  const _summarize: TidyFn<T, A.Compute<Output>> = (\n    items: T[]\n  ): A.Compute<Output>[] => {\n    options = options ?? ({} as Options);\n\n    // reduce but use a loop to be more readable\n    const summarized = {} as Output;\n    const keys = Object.keys(summarizeSpec) as (keyof SummarizedSpec)[];\n\n    for (const key of keys) {\n      summarized[key as keyof Output] = summarizeSpec[key](items);\n    }\n\n    // if we a function to apply to the rest of the keys is supplied, use it\n    // TODO: improve types for rest\n    if (options.rest && items.length) {\n      const objectKeys = Object.keys(items[0]) as (keyof T)[];\n      for (const objKey of objectKeys) {\n        if (keys.includes(objKey as any)) {\n          continue;\n        }\n\n        (summarized as any)[objKey] = options.rest(objKey)(items);\n      }\n    }\n\n    return [summarized] as A.Compute<Output>[];\n  };\n\n  return _summarize;\n}\n\n/*-------- summarize helpers ----------------------------------------*/\n\nexport type SummaryKeyFn<T, K = keyof T> = (key: K) => (items: T[]) => any;\n\nfunction _summarizeHelper<\n  T extends object,\n  SummarizedT extends object = { [K in keyof T]: any }\n>(\n  items: T[],\n  summaryFn: SummaryKeyFn<T>,\n  predicateFn?: (vector: Vector<T>) => boolean,\n  keys?: Array<keyof T | ((items: T[]) => (keyof T)[])>\n): SummarizedT[] {\n  if (!items.length) return [];\n\n  // reduce but use a loop to be more readable\n  const summarized = {} as SummarizedT;\n\n  // read in keys from first object if not provided\n  let keysArr: (keyof T)[];\n  if (keys == null) {\n    keysArr = Object.keys(items[0]) as (keyof T)[];\n  } else {\n    // expand them all to a flat list of keys\n    keysArr = [];\n    for (const keyInput of singleOrArray(keys as any)) {\n      if (typeof keyInput === 'function') {\n        keysArr.push(...(keyInput(items) as (keyof T)[]));\n      } else {\n        keysArr.push(keyInput);\n      }\n    }\n  }\n\n  for (const key of keysArr) {\n    if (predicateFn) {\n      // inefficient to compute this vector here, wonder if it should\n      // be computed prior to this func being called somehow? (TODO)\n      const vector = items.map((d) => d[key]);\n      if (!predicateFn(vector)) {\n        continue;\n      }\n    }\n    summarized[(key as unknown) as keyof SummarizedT] = summaryFn(key)(\n      items\n    ) as any;\n  }\n\n  return [summarized];\n}\n\n/*---- summarizeAll() --------------------------------------------*/\n\ntype SummaryFnOutput<T extends object, F extends SummaryKeyFn<T>> = ReturnType<\n  ReturnType<F>\n>;\n\nexport function summarizeAll<T extends object, F extends SummaryKeyFn<T>>(\n  summaryFn: F\n): TidyFn<T, A.Compute<Record<keyof T, SummaryFnOutput<T, F>>>> {\n  const _summarizeAll: TidyFn<\n    T,\n    A.Compute<Record<keyof T, SummaryFnOutput<T, F>>>\n  > = (items: T[]): A.Compute<Record<keyof T, SummaryFnOutput<T, F>>>[] =>\n    _summarizeHelper(items, summaryFn);\n\n  return _summarizeAll;\n}\n\n/*---- summarizeIf() --------------------------------------------*/\n// type is not perfect since it returns all keys of T, but better to have more than less I figure\nexport function summarizeIf<T extends object, F extends SummaryKeyFn<T>>(\n  predicateFn: (vector: Vector<T>) => boolean,\n  summaryFn: F\n): TidyFn<T, A.Compute<Record<keyof T, SummaryFnOutput<T, F>>>> {\n  const _summarizeIf: TidyFn<\n    T,\n    A.Compute<Record<keyof T, SummaryFnOutput<T, F>>>\n  > = (items: T[]): A.Compute<Record<keyof T, SummaryFnOutput<T, F>>>[] =>\n    _summarizeHelper(items, summaryFn, predicateFn);\n\n  return _summarizeIf;\n}\n\n/*---- summarizeAt() --------------------------------------------*/\nexport function summarizeAt<\n  T extends object,\n  Keys extends (keyof T)[],\n  F extends SummaryKeyFn<T, Keys[number]>\n>(\n  keys: Keys,\n  summaryFn: F\n): TidyFn<T, A.Compute<Record<Keys[number], SummaryFnOutput<T, F>>>> {\n  const _summarizeAt: TidyFn<\n    T,\n    A.Compute<Record<Keys[number], SummaryFnOutput<T, F>>>\n  > = (items: T[]): A.Compute<Record<Keys[number], SummaryFnOutput<T, F>>>[] =>\n    _summarizeHelper(items, summaryFn, undefined, keys);\n\n  return _summarizeAt;\n}\n"],"names":["singleOrArray"],"mappings":";;;;;;mBA8BE,eACA;AAIA,QAAM,aAA2C,CAC/C;AAEA,cAAU,4BAAY;AAGtB,UAAM,aAAa;AACnB,UAAM,OAAO,OAAO,KAAK;AAEzB,eAAW,OAAO;AAChB,iBAAW,OAAuB,cAAc,KAAK;AAAA;AAKvD,QAAI,QAAQ,QAAQ,MAAM;AACxB,YAAM,aAAa,OAAO,KAAK,MAAM;AACrC,iBAAW,UAAU;AACnB,YAAI,KAAK,SAAS;AAChB;AAAA;AAGF,QAAC,WAAmB,UAAU,QAAQ,KAAK,QAAQ;AAAA;AAAA;AAIvD,WAAO,CAAC;AAAA;AAGV,SAAO;AAAA;AAOT,0BAIE,OACA,WACA,aACA;AAEA,MAAI,CAAC,MAAM;AAAQ,WAAO;AAG1B,QAAM,aAAa;AAGnB,MAAI;AACJ,MAAI,QAAQ;AACV,cAAU,OAAO,KAAK,MAAM;AAAA;AAG5B,cAAU;AACV,eAAW,YAAYA,4BAAc;AACnC,UAAI,OAAO,aAAa;AACtB,gBAAQ,KAAK,GAAI,SAAS;AAAA;AAE1B,gBAAQ,KAAK;AAAA;AAAA;AAAA;AAKnB,aAAW,OAAO;AAChB,QAAI;AAGF,YAAM,SAAS,MAAM,IAAI,CAAC,MAAM,EAAE;AAClC,UAAI,CAAC,YAAY;AACf;AAAA;AAAA;AAGJ,eAAY,OAAwC,UAAU,KAC5D;AAAA;AAIJ,SAAO,CAAC;AAAA;sBAUR;AAEA,QAAM,gBAGF,CAAC,UACH,iBAAiB,OAAO;AAE1B,SAAO;AAAA;qBAMP,aACA;AAEA,QAAM,eAGF,CAAC,UACH,iBAAiB,OAAO,WAAW;AAErC,SAAO;AAAA;qBASP,MACA;AAEA,QAAM,eAGF,CAAC,UACH,iBAAiB,OAAO,WAAW,QAAW;AAEhD,SAAO;AAAA;;;;;;;"}