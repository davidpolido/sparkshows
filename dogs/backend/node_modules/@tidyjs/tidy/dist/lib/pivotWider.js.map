{"version":3,"file":"pivotWider.js","sources":["../../src/pivotWider.ts"],"sourcesContent":["import { groupBy } from './groupBy';\nimport { SingleOrArray } from './helpers/singleOrArray';\nimport { tidy } from './tidy';\nimport { Key, TidyFn } from './types';\n\ntype PivotOutput = Record<Key, any>;\n\ntype PivotWiderOptions<T extends object> = {\n  namesFrom: SingleOrArray<keyof T>;\n  namesSep?: string;\n  valuesFrom: SingleOrArray<keyof T>;\n  valuesFill?: any;\n  valuesFillMap?: Partial<Record<Key, any>>;\n};\n\nexport function pivotWider<T extends object>(\n  options: PivotWiderOptions<T>\n): TidyFn<T, PivotOutput> {\n  const _pivotWider: TidyFn<T, PivotOutput> = (items: T[]): PivotOutput[] => {\n    const {\n      namesFrom,\n      valuesFrom,\n      valuesFill,\n      valuesFillMap,\n      namesSep = '_',\n    } = options;\n\n    const namesFromKeys: (keyof T)[] = Array.isArray(namesFrom)\n      ? namesFrom\n      : [namesFrom];\n    const valuesFromKeys: (keyof T)[] = Array.isArray(valuesFrom)\n      ? valuesFrom\n      : [valuesFrom];\n    const wider: PivotOutput[] = [];\n\n    if (!items.length) return wider;\n\n    // get all the keys that are left (id columns)\n    const idColumns = Object.keys(items[0]).filter(\n      (key) =>\n        !namesFromKeys.includes(key as keyof T) &&\n        !valuesFromKeys.includes(key as keyof T)\n    ) as (keyof T)[];\n\n    // get all possibilities for the name properties so we can fill them\n    const nameValuesMap: any = {};\n    for (const item of items) {\n      for (const nameKey of namesFromKeys) {\n        if (nameValuesMap[nameKey] == null) {\n          nameValuesMap[nameKey] = {};\n        }\n        nameValuesMap[nameKey][item[nameKey]] = true;\n      }\n    }\n\n    const nameValuesLists: string[][] = [];\n    for (const nameKey in nameValuesMap) {\n      nameValuesLists.push(Object.keys(nameValuesMap[nameKey]));\n    }\n\n    // prefill values if valuesFill is set for each name values combination\n    const baseWideObj: any = {};\n    const combos = makeCombinations(namesSep, nameValuesLists);\n\n    for (const nameKey of combos) {\n      if (valuesFromKeys.length === 1) {\n        baseWideObj[nameKey] =\n          valuesFillMap != null\n            ? valuesFillMap[valuesFromKeys[0] as any]\n            : valuesFill;\n        continue;\n      }\n\n      for (const valueKey of valuesFromKeys) {\n        baseWideObj[`${valueKey}${namesSep}${nameKey}`] =\n          valuesFillMap != null ? valuesFillMap[valueKey as any] : valuesFill;\n      }\n    }\n\n    // given a collection of items, widen\n    function widenItems(items: T[]) {\n      if (!items.length) return [];\n\n      const wide: PivotOutput = { ...baseWideObj };\n\n      // add the id columns (same for each object, so just look at first)\n      for (const idKey of idColumns) {\n        wide[idKey as keyof PivotOutput] = items[0][idKey];\n      }\n\n      // go through each object and widen their values\n      for (const item of items) {\n        const nameKey = namesFromKeys.map((key) => item[key]).join(namesSep);\n\n        if (valuesFromKeys.length === 1) {\n          wide[nameKey] = item[valuesFromKeys[0]];\n          continue;\n        }\n\n        for (const valueKey of valuesFromKeys) {\n          wide[`${valueKey}${namesSep}${nameKey}`] = item[valueKey];\n        }\n      }\n      return [wide];\n    }\n\n    // no id columns, don't do any grouping, just widen and return\n    if (!idColumns.length) {\n      return widenItems(items);\n    }\n\n    // group by the id columns\n    // for each group, widen/flatten to a single value\n    const finish = tidy(items, groupBy(idColumns, [widenItems]));\n    return finish;\n  };\n\n  return _pivotWider;\n}\n\n/*\n  Recursively compute key combinations\n*/\nfunction makeCombinations(separator = '_', arrays: string[][]): string[] {\n  function combine(\n    accum: string[],\n    prefix: string | null,\n    remainingArrays: string[][]\n  ) {\n    if (!remainingArrays.length && prefix != null) {\n      accum.push(prefix);\n      return;\n    }\n\n    const array = remainingArrays[0];\n    const newRemainingArrays = remainingArrays.slice(1);\n    for (const item of array) {\n      combine(\n        accum,\n        prefix == null ? item : `${prefix}${separator}${item}`,\n        newRemainingArrays\n      );\n    }\n  }\n\n  const result: string[] = [];\n  combine(result, null, arrays);\n  return result;\n}\n"],"names":["tidy","groupBy"],"mappings":";;;;;;;oBAgBE;AAEA,QAAM,cAAsC,CAAC;AAC3C,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,WAAW;AAAA,QACT;AAEJ,UAAM,gBAA6B,MAAM,QAAQ,aAC7C,YACA,CAAC;AACL,UAAM,iBAA8B,MAAM,QAAQ,cAC9C,aACA,CAAC;AACL,UAAM,QAAuB;AAE7B,QAAI,CAAC,MAAM;AAAQ,aAAO;AAG1B,UAAM,YAAY,OAAO,KAAK,MAAM,IAAI,OACtC,CAAC,QACC,CAAC,cAAc,SAAS,QACxB,CAAC,eAAe,SAAS;AAI7B,UAAM,gBAAqB;AAC3B,eAAW,QAAQ;AACjB,iBAAW,WAAW;AACpB,YAAI,cAAc,YAAY;AAC5B,wBAAc,WAAW;AAAA;AAE3B,sBAAc,SAAS,KAAK,YAAY;AAAA;AAAA;AAI5C,UAAM,kBAA8B;AACpC,eAAW,WAAW;AACpB,sBAAgB,KAAK,OAAO,KAAK,cAAc;AAAA;AAIjD,UAAM,cAAmB;AACzB,UAAM,SAAS,iBAAiB,UAAU;AAE1C,eAAW,WAAW;AACpB,UAAI,eAAe,WAAW;AAC5B,oBAAY,WACV,iBAAiB,OACb,cAAc,eAAe,MAC7B;AACN;AAAA;AAGF,iBAAW,YAAY;AACrB,oBAAY,GAAG,WAAW,WAAW,aACnC,iBAAiB,OAAO,cAAc,YAAmB;AAAA;AAAA;AAK/D,wBAAoB;AAClB,UAAI,CAAC,OAAM;AAAQ,eAAO;AAE1B,YAAM,OAAoB,IAAK;AAG/B,iBAAW,SAAS;AAClB,aAAK,SAA8B,OAAM,GAAG;AAAA;AAI9C,iBAAW,QAAQ;AACjB,cAAM,UAAU,cAAc,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK;AAE3D,YAAI,eAAe,WAAW;AAC5B,eAAK,WAAW,KAAK,eAAe;AACpC;AAAA;AAGF,mBAAW,YAAY;AACrB,eAAK,GAAG,WAAW,WAAW,aAAa,KAAK;AAAA;AAAA;AAGpD,aAAO,CAAC;AAAA;AAIV,QAAI,CAAC,UAAU;AACb,aAAO,WAAW;AAAA;AAKpB,UAAM,SAASA,UAAK,OAAOC,gBAAQ,WAAW,CAAC;AAC/C,WAAO;AAAA;AAGT,SAAO;AAAA;AAMT,0BAA0B,YAAY,KAAK;AACzC,mBACE,OACA,QACA;AAEA,QAAI,CAAC,gBAAgB,UAAU,UAAU;AACvC,YAAM,KAAK;AACX;AAAA;AAGF,UAAM,QAAQ,gBAAgB;AAC9B,UAAM,qBAAqB,gBAAgB,MAAM;AACjD,eAAW,QAAQ;AACjB,cACE,OACA,UAAU,OAAO,OAAO,GAAG,SAAS,YAAY,QAChD;AAAA;AAAA;AAKN,QAAM,SAAmB;AACzB,UAAQ,QAAQ,MAAM;AACtB,SAAO;AAAA;;;;"}